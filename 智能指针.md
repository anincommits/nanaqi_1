C++ 引入智能指针的主要目的是为了自动化内存管理，减少手动 *new* 和 *delete* 带来的复杂性和[[指针#手动管理指针可能出现以下问题：|错误]]。
智能指针通过[[RAII|RAII]]，在对象生命周期结束时自动释放资源，从而有效[[智能指针的优势|防止内存泄漏和资源管理错误]]。
使用智能指针要```#include <memory>
##  std::unique_ptr
`std::unique_ptr` 是一种独占所有权的智能指针，任何时刻只能有一个 `unique_ptr` 实例拥有对某个对象的所有权。不能被拷贝，只能被移动。
 主要特性：
- **独占所有权**：确保资源在一个所有者下。
- **轻量级**：没有引用计数，开销小。
- **自动释放**：在指针销毁时自动释放资源。
```CPP
   // 创建一个 unique_ptr
   std::unique_ptr<Test> ptr1(new Test(/*构造Test的参数*/));

   // 使用 make_unique（C++14 引入）
   auto ptr2 = std::make_unique<Test>(/*构造Test的参数*/);

   // 移动 unique_ptr
   std::unique_ptr<Test> ptr3 = std::move(ptr1);
   
   // 重置 unique_ptr
   ptr2.reset(new Test(/*构造Test的参数*/));
   ```


## std::shared_ptr
`std::shared_ptr` 是一种共享所有权的智能指针，允许多个 `shared_ptr` 实例共享对同一个对象的所有权。通过引用计数机制，管理资源的生命周期。
主要特性：
- **共享所有权**：多个 `shared_ptr` 可以指向同一个对象。
- **引用计数**：跟踪有多少 `shared_ptr` 实例指向同一对象。
- **自动释放**：当引用计数为0时，自动释放资源。

`shared_ptr`背后依赖一个控制块（Control Block），用于存储引用计数和指向实际对象的指针。控制块的主要内容包括：
- **强引用计数（`use_count`）**：表示有多少个 `shared_ptr` 指向对象。
- **弱引用计数（`weak_count`）**：表示有多少个 `weak_ptr` 指向对象（不增加强引用计数）。
 ```CPP
auto * Testptr=new Test();

std::shared_ptr<Test> _p (Testptr);
//通过Testptr生成临智能指针_p

std::share_ptr<Test> _p2=std::shared_ptr<Test>(Testptr);
//通过Testptr生成临时的智能指针，再移动给_p2

std::shared_ptr<Test> _p3 (new Test ());

auto _p4=std::make_shared<Test>();
```
## std::weak_ptr
`std::weak_ptr` 是一种不拥有对象所有权的智能指针，用于观察但不影响对象的生命周期。主要用于解决 `shared_ptr` 之间的循环引用问题。
主要特性：
- **非拥有所有权**：不增加引用计数。
- **可从 `shared_ptr` 生成**：通过 `std::weak_ptr` 可以访问 `shared_ptr` 管理的对象。
- **避免循环引用**：适用于双向关联或观察者模式。
#### 避免循环引用
在存在双向关联（如父子关系）时，使用多个 `shared_ptr` 可能导致循环引用，导致内存泄漏。此时，可以使用 `weak_ptr` 来打破循环。
```CPP
#include <iostream>
#include <memory>
class B; // 前向声明

class A {
public:
    std::shared_ptr<B> ptrB;

    A() { std::cout << "A Constructor" << std::endl; }
    ~A() { std::cout << "A Destructor" << std::endl; }
};

class B {
public:
    std::shared_ptr<A> ptrA;

    B() { std::cout << "B Constructor" << std::endl; }
    ~B() { std::cout << "B Destructor" << std::endl; }
};

int main() {
    {
        std::shared_ptr<A> a = std::make_shared<A>();
        std::shared_ptr<B> b = std::make_shared<B>();
        a->ptrB = b;
        b->ptrA = a;
    }
    std::cout << "Exiting main..." << std::endl;
    return 0;
}
```
输出:
```CPP
A Constructor
B Constructor
Exiting main...
A Destructor
B Destructor
```
虽然 `a` 和 `b` 离开作用域，但 `A Destructor` 和 `B Destructor` 并未被调用，因为 `a` 和 `b` 相互引用，引用计数无法降到0，导致内存泄漏。
#### 解决方案：使用 `weak_ptr`
改用`weak_ptr`（如 `B` 的 `ptrA`），打破循环引用。
**解析**：
- `B` 使用 `weak_ptr` 指向 `A`，不增加引用计数。
- `a` 和 `b` 离开作用域，引用计数降为0，资源被正确释放。
- 防止了循环引用，避免了内存泄漏。
### 访问 `weak_ptr` 指向的对象
`weak_ptr` 不能直接访问对象，需要通过 `lock()` 方法转换为 `shared_ptr`，并检查对象是否仍然存在。
```CPP
#include <iostream>
#include <memory>
int main() {
    std::shared_ptr<int> sp = std::make_shared<int>(42);
    std::weak_ptr<int> wp = sp;

    if (auto locked = wp.lock()) { // 尝试获取 shared_ptr
        std::cout << "Value: " << *locked << std::endl;
    } else {
        std::cout << "Object no longer exists." << std::endl;
    }

    sp.reset(); // 释放资源

    if (auto locked = wp.lock()) { // 再次尝试获取 shared_ptr
        std::cout << "Value: " << *locked << std::endl;
    } else {
        std::cout << "Object no longer exists." << std::endl;
    }

    return 0;
}
```
**输出**：
```CPP
Value: 42
Object no longer exists.
```
## 自定义删除器
有时，默认的 `delete` 操作不适用于所有资源管理场景。此时，可以使用自定义删除器来指定资源释放的方式。例如，管理文件句柄、网络资源或自定义清理逻辑。
