**运算符重载（Operator Overloading)** 允许开发者为自定义类型定义或重新定义运算符的行为，使得自定义类型的对象能够使用与内置类型相同的运算符进行操作。
## 运算符重载的规则与限制

1. **不能改变运算符的优先级和结合性**：运算符的优先级和结合性在编译阶段就确定，不能通过重载来改变。
2. **不能创建新的运算符**：仅能重载C++中已有的运算符，不能定义新的运算符。
3. **至少有一个操作数必须是用户定义的类型**：不能对两个内置类型进行运算符重载。
4. **某些运算符不能重载**：包括 `.`（成员选择运算符）、`.*`、`::`、`?:`（条件运算符）等。
## 运算符重载的方法

在C++中，运算符可以通过成员函数或非成员函数（通常是友元函数）来重载。
### 成员函数方式

运算符作为类的成员函数进行重载时，左操作数是当前对象（`this`）。因此，对于需要修改左操作数的运算符，成员函数方式通常更直观。

```CPP
class ClassName {
public:
    ClassName operator+(const ClassName& other);
};
```

### 非成员函数方式（友元函数）

当需要对两个不同类型的对象进行运算，或者左操作数不是当前类的对象时，通常使用非成员函数方式。为了访问类的私有成员，非成员函数通常被声明为类的友元函数。
```CPP
class ClassName {
    friend ClassName operator+(const ClassName& lhs, const ClassName& rhs);
};
```
## 1. 算术运算符(+-\*/)
**示例 : 重载+** 
```CPP
#include <iostream>

class Complex {
private:
    double real;
    double imag;

public:
    // 构造函数
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

    // 重载 + 运算符（成员函数）
    Complex operator+(const Complex& other) const {
        return Complex(this->real + other.real, this->imag + other.imag);
    }

    // 重载 << 运算符用于输出
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
};

// 实现 << 运算符
std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << "(" << c.real;
    if (c.imag >= 0)
        os << " + " << c.imag << "i)";
    else
        os << " - " << -c.imag << "i)";
    return os;
}

// 示例
int main() {
    Complex c1(3.0, 4.0);
    Complex c2(1.5, -2.5);
    Complex c3 = c1 + c2;
    std::cout << "c1 + c2 = " << c3 << std::endl;
    return 0;
}
//输出:c1 + c2 = (4.5 + 1.5i)
```
